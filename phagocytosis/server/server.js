//Require and ready all modules.
var sys = require("sys");
var express = require('express');
var app = express();
var http = require('http').Server(app);
var io = require('socket.io')(http);

//Ready express to allow it to deliver the webpage to any clients.
app.use(express.static(__dirname + '/../client'));

//Pretend these are static variables
//Starting mass of a cell.
var STARTMASS = 10;
//Limit of food spawned.
var FOODLIMIT = 2500;
//Dimensions of the map.
var MAPWIDTH = 10000;
var MAPHEIGHT = 10000;
//Constant used in speed calculations.
var SPEEDCONST = 100;
//Amount of mass incremented at a time.
//user.cells[i].mass slowly increases at this rate to user.cells[i].newMass
var MASSINCREMENT = 0.25;
//The minimum mass required to split a cell.
var MINSPLITMASS = 32;
//Constant used in speed calculations for anchoring, when two cells slowly come together after splitting.
var ANCHORSPEEDCONST = 2;
//Constant used in speed calculations for merging cells after splitting.
var MERGESPEEDCONST = 5;
//Multiplier used to see if a cell can eat another cell.
//A cell must be EATMASSMULT times larger than another cell in order to eat it.
var EATMASSMULT = 1.15;
//The number of viruses in the map.
var VIRUSLIMIT = 32;
//Amount of mass in one ejected.
var EJECTMASS = 16;
//Amount of mass returned when absorbing an eject.
var EJECTRETURNMASS = 14;
//Constant used in speed calculations for launching (in splits).
var LAUNCHSPEEDCONST = SPEEDCONST * 30 / 100;
//The base radius for one virus.
var VIRUSRADIUS = 100;
//A multiplier used to see when a virus can split.
//The virus splits when its mass is >= VIRUSSPLITMULT * VIRUSEJECTRETURN
var VIRUSSPLITMULT = 7;
//The max number of cells you can split down to.
var MAXNUMOFCELLS = 8;
//The amount of mass a virus receives from an eject. Much smaller than EJECTMASS to make virus growing seem smoother.
var VIRUSEJECTRETURN = 4;
//Constant used to determine how far a split will travel.
var SPLITDISTMULT = 14;
//Virus launch speed decrease constant:
var VIRUSSPEEDDECCONST = 0.6;
//Eject launch speed decrease constant:
var EJECTSPEEDDECCONST = 0.3;


//A queue where user update positions are pushed into and will be broadcasted to everyone else.
var sendQueue = [];

var users = [];
/*
Each user is represented by one object:
{
	name,		//Username of the user.
	userId,		//A unique id for the user.  
	cells,		//A list of the cells that the user can control.
	hue			//The hue of the cell, used to represent its color (in hsl).
}
Each cell in user.cell is represented by an object:
{
	userId,							//The id of the user it belongs to.
	posX,							//X position.
	posY,							//Y position.
	mass,							//The mass of the cell. It's radius is 2*mass.
	newMass,						//The actual mass of the cell. To make cell growing seem smooth, we slowly increase/decrease mass by MASSINCREMENT to match newMass.
	launchAngle,					//The angle that the cell is launched if it was produced by a split.
	launchSpeed,					//The speed that the cell is launched at if it was produced by a split.
									//launchSpeed slowly decreases after splitting.
	splitFrom,						//The cell that this cell splitFrom. null if it did not split from any cell.
	hasChildren						//Did other cells split from this cell?
}
*/

//A list of food (the small dots you pick up for mass).
var foods = [];
/*
Each food is represented by an object.
{
	posX,			//X position.
	posY,			//Y position.
	hue				//The hue of the food, used for its color (hsl).
}
Foods are generated by generateFoods();
*/

//A list of viruses (the green spiky things).
var viruses = [];
/*
Each virus is represented by an object.
{
	posX,				//X position.
	posY,				//Y position.
	mass,				//Mass of the virus.
	launchSpeed,		//Speed at which the virus was launched.
	launchAngle			//Angle at which the virus was launched.
}
*/

//A list of ejects.
var ejects = [];
/*
Each eject is represented by an object.
{
	userId,				//The id of the user the eject came from.
	posX,				//X position.
	posY,				//Y position.
	hue,				//Hue of the ejects, used in color (hsl). Comes from the user.
	launchAngle,		//The angle the virus was launched from.
	launchSpeed			//The speed the virus was launched at.
}
*/

//Number of users.
var userCount = 0;

//Get the user by id.
var getUserById = function(id){
	//Iterate through all of the users until you find the one where the userId matches.
	for (var i = 0; i < users.length; ++i){
		if (users[i].userId === id)
			return users[i];
	}
}

//Create a new user object.
function newUser(userId,name,cells,hue){
	return {
		userId: userId,
		name: name,
		cells: cells,
		hue: hue
	}
}

//Create a new cell object.
function newCell(userId,posX,posY,mass,newMass,launchAngle,launchSpeed,splitFrom){
	return {
		userId: userId,
		posX: posX,
		posY: posY,
		mass: mass,
		newMass: newMass,
		launchAngle: launchAngle,
		launchSpeed: launchSpeed,
		splitFrom: splitFrom,
		hasChildren: false
	}
}

//Create a new food object.
function newFood(posX,posY,hue){
	return{
		posX: posX,
		posY: posY,
		hue: hue
	}
}

//Create a new virus object.
function newVirus(posX,posY,mass,launchAngle,launchSpeed){
	return{
		posX: posX,
		posY: posY,
		mass: mass,
		launchAngle: launchAngle,
		launchSpeed: launchSpeed
	}
}

//Create a new eject object.
function newEject(userId,posX,posY,hue,launchAngle,launchSpeed){
	return {
		userId: userId,
		posX: posX,
		posY: posY,
		hue: hue,
		launchAngle: launchAngle,
		launchSpeed: launchSpeed
	}
}

//The socket listens for a connection from a client.
//When a client connects:
io.sockets.on('connection',function(socket){
	//Assign it a userId and create a user object for it.
	var userId = userCount++;
	var user = newUser(
		userId,			
		"",				//Empty string for name, will update after greeting the client.
		//A single cell at a random position with the starting mass.
		[newCell(userId,Math.random()*MAPWIDTH,Math.random()*MAPHEIGHT,STARTMASS,STARTMASS,0,0,null)],
		Math.round(Math.random() * 360)		//A random hue.
	);
	//Push the user object into the users list.
	users.push(user);

	/*
	The server waits for the client to greet it by giving it the player's name.
	 - playerName: The player's name.
	*/
	socket.on('client-greet',function(playerName){
		//The server assigns the name.
		user.name = playerName;
		//The server greets the client by giving it the users list, userId list, viruses list, and foods list.
		socket.emit('server-greet',{
			users: users,
			userId: userId,
			viruses: viruses,
			foods: foods,
		});
		//The server emits to all the clients that a new user has joined, giving them the new user object.
		io.sockets.emit('new-client',user);
	});

	/*
	The player requests a respawn, with a possibly new playerName:
	 - playerName: The player's name.
	*/
	socket.on('player-respawn',function(playerName){
		//Assign that name.
		user.name = playerName;
		//Create a new cell for the user.
		user.cells = [newCell(userId,Math.random()*MAPWIDTH,Math.random()*MAPHEIGHT,STARTMASS,STARTMASS,0,0,null)];
	});

	//The player disconnected from the server:
	socket.on('disconnect',function(){
		//Find the user object and delete it.
		for (var i = 0; i < users.length; ++i){
			if (users[i].userId === userId){
				users.splice(i,1);
				break;
			}
		}
		//Emit to all clients that this player has disconnected.
		io.sockets.emit('player-disconnect',{
			userId: userId		//The userId of the player that disconnected.
		});
	});

	/*
	The player sends the server the current mouse angle.
	 - angle: The current angle of the mouse from the cells. Used in movement.
	*/
	socket.on('update-from-client',function(angle){
		//Iterate through all the cells:
		for (var i = user.cells.length-1; i >= 0; --i){
			//If the launchSpeed of the cell is still greater than it's normal speed:
			if (user.cells[i].launchSpeed > STARTMASS / Math.sqrt(user.cells[i].mass)){
				//Update the cell to travel at its launchSpeed.
				user.cells[i].posX += Math.cos(user.cells[i].launchAngle) * user.cells[i].launchSpeed;
				user.cells[i].posY += Math.sin(user.cells[i].launchAngle) * user.cells[i].launchSpeed;
				//Find the parent of the cell, the one it split from.
				var parent = user.cells[i].splitFrom;
				//If the distance between the parent and the child is greater than a set distance.
				if (Math.hypot(user.cells[i].posX - parent.posX, user.cells[i].posY - parent.posY) > user.cells[i].mass * SPLITDISTMULT)
					user.cells[i].launchSpeed /= 2;
			}
			else{
				//Update the cell to travel at it's normal speed, depending on its mass.
				//As cells increase in size, they decrease in speed.
				user.cells[i].posX += Math.cos(angle) * SPEEDCONST / user.cells[i].mass;
				user.cells[i].posY += Math.sin(angle) * SPEEDCONST / user.cells[i].mass;

				//Make the cells slowly travel towards each other before mergin.
				//If the cell split from a parent and wasn't the base cell:
				if (user.cells[i].splitFrom != null){
					//Find the parent of the cell and the angle from the parent.
					var parent = user.cells[i].splitFrom;
					var parentAngle = Math.atan2(parent.posY - user.cells[i].posY, parent.posX - user.cells[i].posX);

					//Determine which cell should move closer to the other cell: the parent to the child, or the child to the parent.
					//This is important because it has to be in the same direction of the movement of both cells.
					//If the parentAngle is in the same general direction of the move angle:
					if (Math.floor(parentAngle) == Math.floor(angle)){
						//Move the current cell closer to the parent cell.

						//If the two cells are touching, decrease the speed by a lot (/ MERGESPEEDCONST).
						if (Math.hypot(user.cells[i].posX - parent.posX, user.cells[i].posY - parent.posY) <= 2*(user.cells[i].mass + parent.mass)){
							user.cells[i].posX += Math.cos(parentAngle) / MERGESPEEDCONST;
							user.cells[i].posY += Math.sin(parentAngle) / MERGESPEEDCONST;
						}
						//Otherwise, make them move towards each other pretty quickly (* ANCHORSPEEDCONST).
						else{
							user.cells[i].posX += Math.cos(parentAngle) * ANCHORSPEEDCONST;
							user.cells[i].posY += Math.sin(parentAngle) * ANCHORSPEEDCONST;
						}
					}
					else{
						//Move the parent cell closer to the parent cell.
						
						//If the two cells are touching, decrease the speed by a lot (/ MERGESPEEDCONST).
						if (Math.hypot(user.cells[i].posX - parent.posX, user.cells[i].posY - parent.posY) <= 2*(user.cells[i].mass + parent.mass)){
							parent.posX += Math.cos((parentAngle+180)%360) / MERGESPEEDCONST;
							parent.posY += Math.sin((parentAngle+180)%360) / MERGESPEEDCONST;
						}
						//Otherwise, make them move towards each other pretty quickly (* ANCHORSPEEDCONST).
						else{
							parent.posX += Math.cos((parentAngle+180)%360) * ANCHORSPEEDCONST;
							parent.posY += Math.sin((parentAngle+180)%360) * ANCHORSPEEDCONST;
						}
					}

					//If the two cells have moved close to each other enough that the center of one cell is in the other cell, merge the cells.
					if (Math.hypot(user.cells[i].posX - parent.posX, user.cells[i].posY - parent.posY) <= user.cells[i].mass + parent.mass){
						//Make the parent cell the bigger of the two cells.
						parent.mass = Math.max(parent.mass, user.cells[i].mass);
						//Combine the newMass of both cells.
						parent.newMass += user.cells[i].newMass;
						//Delete the child cell.
						user.cells.splice(i,1);
						//Do not perform the rest of the loop for the deleted cell.
						continue;
					}
					else{
						//Keep the cell inside the game area, from overstepping the boundaries.
						user.cells[i].posX = Math.max(user.cells[i].posX,user.cells[i].mass*2);
						user.cells[i].posY = Math.max(user.cells[i].posY,user.cells[i].mass*2);
						user.cells[i].posX = Math.min(user.cells[i].posX,MAPWIDTH-user.cells[i].mass*2);
						user.cells[i].posY = Math.min(user.cells[i].posY,MAPHEIGHT-user.cells[i].mass*2);
					}
				}
				else{
					//Keep the cell inside the game area, from overstepping the boundaries.
					user.cells[i].posX = Math.max(user.cells[i].posX,user.cells[i].mass*2);
					user.cells[i].posY = Math.max(user.cells[i].posY,user.cells[i].mass*2);
					user.cells[i].posX = Math.min(user.cells[i].posX,MAPWIDTH-user.cells[i].mass*2);
					user.cells[i].posY = Math.min(user.cells[i].posY,MAPHEIGHT-user.cells[i].mass*2);
				}
			}

			//Check if this cell can eat other cells.
			for (var j = 0; j < users.length; ++j){
				//Don't check for cells of the same user.
				if (userId == users[j].userId) continue;
				for (var k = users[j].cells.length-1; k >= 0; --k){
					//If this cell is greater than the checked cell multiplied by a constant (* EATMASSMULT):
					if (users[j].cells[k].mass * EATMASSMULT <= user.cells[i].mass &&
					//And the center of this cell is within the checked cell:
						Math.hypot(users[j].cells[k].posX - user.cells[i].posX,users[j].cells[k].posY - user.cells[i].posY) <= user.cells[i].mass*2){
						//Eat the check cell and give its mass to this cell.
						user.cells[i].newMass += users[j].cells[k].newMass;
						//Delete the checked cell.
						users[j].cells.splice(k,1);
					}
				}
				//If the user with the checked cell now no longer has cells, report that it died.
				if (users[j].cells.length == 0){
					//Emit the userId of the user that died.
					io.sockets.emit("client-died",users[j].userId);
				}
			}
		}
		//Tell the emitLoop to emit for this user to all other clients.
		sendQueue.push(userId);
	});

	/*
	The client tells the server that the player wants to split the cell:
	 - angle: The angle to launch the new cells.
	*/
	socket.on('split-by-client',function(angle){
		//If the user can split, and has not exceeded the MAXNUMCELLS:
		if (user.cells.length <= MAXNUMOFCELLS/2){
			//Iterate through all the current cells (keeping track with splitLength) and duplicate them, launching the new ones in the given angle).
			var splitLength = user.cells.length;
			for (var i = 0; i < splitLength; ++i){
				//If the mass of the current cell is greater than the specified minimum (MINSPLITMASS):
				if (user.cells[i].mass >= MINSPLITMASS){
					//Create a new child cell with half of the mass of the original cell and launch it.
					user.cells.push(newCell(
						userId,
						user.cells[i].posX,			//Same X position as the original cell.
						user.cells[i].posY,			//Same Y position as the original cell.
						user.cells[i].mass/2,		//Half of the mass of the original cell.
						user.cells[i].newMass/2,	//Half of the newMass of the original cell.
						angle,
						LAUNCHSPEEDCONST,			//Give it a launch speed constant.
						user.cells[i]));			//Give it a pointer to the original parent cell.
					//Half the masses of the original cell.
					user.cells[i].mass /= 2;
					user.cells[i].newMass /= 2;
				}
			}
		}
	});

	/*
	The client tells the server that the player wants to eject mass from the cell.
	 - angle: The angle at which to eject the mass.
	*/
	socket.on('eject-by-client',function(angle){
		//Eject mass from each cell that can.
		for (var i = 0; i < user.cells.length; ++i){
			//If the mass of this cell is greater than the minimum (can create two cells of EJECTMASS):
			if (user.cells[i].newMass >= 2*EJECTMASS){
				user.cells[i].newMass -= EJECTMASS;
				//Create the new eject object.
				ejects.push(newEject(
					userId,																	//Id of the user that the eject came from.
					user.cells[i].posX + Math.cos(angle) * (2*user.cells[i].mass + 1),		//X position of the edge of the cell.
					user.cells[i].posY + Math.sin(angle) * (2*user.cells[i].mass + 1),		//Y position of the edge of the cell.
					user.hue,																//Hue of the eject (from user).
					angle,																	//Angle that the eject is launched from.
					LAUNCHSPEEDCONST / 2													//Speed constant that the eject is launched at.
				));
			}
		}
	});

	/*
	Debug code to increase the mass of the cell when the client tells the server to.
	socket.on('debug-incr',function(){
		++user.cells[0].newMass;
	});
	*/
});

//The loop that constantly emits player updates to all clients, using userIds in sendQueue.
var emitLoop = function(){
	//If sendQueue is not empty:
	if (sendQueue.length > 0){
		//Get the user to update.
		var id = sendQueue.shift();
		var user = getUserById(id);
		//If the user has disconnected already, just ignore it.
		if (user == null) return;
		//Otherwise, update the user to all clients.
		io.sockets.emit('update-from-server',{
			userId: id,				//The id of the user.
			cells: user.cells		//The cells of the user.
		});
	}
};

//The loop that constantly checks for collisions between all objects.
var collideLoop = function(){
	for (var i = 0; i < users.length; ++i){
		for (var j = 0; j < users[i].cells.length; ++j){
			//Check collisions between cells and food.
			for (var k = foods.length-1; k >= 0; --k){
				//If the cell is over the food:
				if (Math.hypot(users[i].cells[j].posX-foods[k].posX,users[i].cells[j].posY-foods[k].posY) <= users[i].cells[j].mass*2){
					//Increase the mass of the cell.
					++users[i].cells[j].newMass;
					//Emit that this food has been eaten (give it its id).
					io.sockets.emit('food-eaten',{food: k});
					//Delete that food from the list.
					foods.splice(k,1);
				}
			}

			//Check collisions between player and viruses.
			for (var k = viruses.length-1; k >= 0; --k){
				//If the cell is large enough to be affected by the virus:
				if (users[i].cells[j].mass*2 >= EATMASSMULT * (VIRUSRADIUS + viruses[k].mass)/2 && 
				//And the center of the virus is in the cell:
					Math.hypot(users[i].cells[j].posX - viruses[k].posX, users[i].cells[j].posY - viruses[k].posY) <= VIRUSRADIUS + viruses[k].mass){
					//Add the mass of the virus to the cell.
					users[i].cells[j].newMass += viruses[k].mass;
					//Delete the virus from the list.
					viruses.splice(k,1);
					//Split the cell to MAXNUMOFCELLS as long as it can, with cells with EJECTMASS.
					for (var l = users[i].cells.length; l < MAXNUMOFCELLS; ++l){
						//Remove EJECTMASS from the mass of the user.
						users[i].cells[j].newMass -= EJECTMASS;
						//Add a new cell with EJECTMASS mass.
						users[i].cells.push(newCell(
							users[i].userId,			//Same userId as the parent cell.
							users[i].cells[j].posX,		//Same X position.
							users[i].cells[j].posY,		//Same Y position.
							EJECTMASS,					
							EJECTMASS,
							Math.random() * 360,		//Random angle.
							LAUNCHSPEEDCONST / 2,		//Half of the LAUNCHSPEEDCONST.
							users[i].cells[j]			//The parent of the new cell is the original cell.
						));
						//If the cell can no longer split, stop.
						if (users[i].newMass < 2*EJECTMASS)
							break;
					}
				}
			}

			//Check collisions between player and viruses:
			for (var k = ejects.length-1; k >= 0; --k){
				//If this cell is over the eject:
				if (Math.hypot(users[i].cells[j].posX-ejects[k].posX,users[i].cells[j].posY-ejects[k].posY) <= users[i].cells[j].mass*2){
					//Absorb it into its mass.
					users[i].cells[j].newMass += EJECTRETURNMASS;
					//Delete this eject from the list.
					ejects.splice(k,1);
				}
			}

			//Increase / Decrease the mass to reach the newMass by MASSINCREMENT.
			//If mass exceeds newMass, make mass = newMass (to prevent mass moving up and down trying to reach newMass).
			if (users[i].cells[j].mass < users[i].cells[j].newMass)
				users[i].cells[j].mass = Math.min(users[i].cells[j].newMass, users[i].cells[j].mass + MASSINCREMENT);
			else
				users[i].cells[j].mass = Math.max(users[i].cells[j].newMass, users[i].cells[j].mass - MASSINCREMENT);
		}
	}

	//Check collisions between viruses and ejects.
	for (var i = 0; i < viruses.length; ++i){
		for (var j = ejects.length-1; j >= 0; --j){
			//If the virus is over the eject:
			if (Math.hypot(viruses[i].posX-ejects[j].posX,viruses[i].posY-ejects[j].posY) <= VIRUSRADIUS + viruses[i].mass){
				//Add to the mass of the virus.
				viruses[i].mass += VIRUSEJECTRETURN;
				//If the mass of the virus is at it's limit (VIRUSSPLITMULT * VIRUSEJECTRETURN):
				if (viruses[i].mass >= VIRUSSPLITMULT * VIRUSEJECTRETURN){
					//Create a new virus and launch it at the angle that the eject hit the virus:
					viruses.push(newVirus(
						viruses[i].posX,		//Same X position.
						viruses[i].posY,		//Same Y position.
						0,
						LAUNCHSPEEDCONST,		//At the constant launch speed.
						Math.atan2(viruses[i].posY - getUserById(ejects[j].userId).cells[0].posY, viruses[i].posX - getUserById(ejects[j].userId).cells[0].posX)	//At the angle that the eject hit the virus.
					));
					//Reset the mass of the original mass.
					viruses[i].mass = 0;
				}
				//Delete the eject that fed the virus.
				ejects.splice(j,1);
			}
		}
	}
	
	//Update launching for viruses:
	for (var i = 0; i < viruses.length; ++i){
		//Update the position of the virus.
		viruses[i].posX += Math.cos(viruses[i].launchAngle) * viruses[i].launchSpeed;
		viruses[i].posY += Math.sin(viruses[i].launchAngle) * viruses[i].launchSpeed;
		//Decrease the launchSpeed of the virus.
		viruses[i].launchSpeed -= VIRUSSPEEDDECCONST;
		//If the laucnhSpeed of the virus is pretty close to zero, make it zero.
		if (viruses[i].launchSpeed < 0.1)
			viruses[i].launchSpeed = 0;
	}

	//Update launching for ejects.
	for (var i = 0; i < ejects.length; ++i){
		//Update the position of the eject.
		ejects[i].posX += Math.cos(ejects[i].launchAngle) * ejects[i].launchSpeed;
		ejects[i].posY += Math.sin(ejects[i].launchAngle) * ejects[i].launchSpeed;
		//Decrease the launchSpeed of the eject.
		ejects[i].launchSpeed -= EJECTSPEEDDECCONST;
		//If the laucnhSpeed of the eject is pretty close to zero, make it zero.
		if (ejects[i].launchSpeed < 0.1)
			ejects[i].launchSpeed = 0;
	}

	//Update all players of the positions of the ejects and the viruses.
	io.sockets.emit('ejects-update',ejects);
	io.sockets.emit('viruses-update',viruses);
}

//Generate the foods used in the map.
var generateFoods = function(){
	for (var i = foods.length; i <= FOODLIMIT; ++i)
		foods.push(newFood(
			Math.random() * MAPWIDTH,			//Random X-position within the map.
			Math.random() * MAPHEIGHT,			//Random Y-position within the map.
			Math.round(Math.random() * 360)		//Random hue for color.
		));
	//Emit the new foods to everyong.
	io.sockets.emit('foods-update',foods);
}

//Generate viruses used in the map.
var generateViruses = function(){
	for (var i = viruses.length; i < VIRUSLIMIT; ++i){
		viruses.push(newVirus(
			Math.random() * MAPWIDTH,			//Random X-position within the map
			Math.random() * MAPHEIGHT,			//Random Y-position within the map.
			//Mass, launchSpeed, launchAngle all zero.
			0,
			0,
			0
		));
	}
	//Emit the new viruses to everyone.
	io.sockets.emit('viruses-update',viruses);
}

generateFoods();
generateViruses();
//Emit every 5 ms.
setInterval(emitLoop,5);
//Check for collisions every 5 ms.
setInterval(collideLoop,5);
//Generate new food every 6 min.
setInterval(function(){generateFoods; generateViruses;},360000);

var serverport = 8081;
var stdin = process.openStdin();
//Ask for a hostname to host on, default localhost.
console.log("Input a hostname: [Default: localhost]");
stdin.addListener("data",function(d){
	var ipaddress = d.toString().substring(0,d.length-2);
	if (ipaddress.length === 0)
		ipaddress = "localhost";
	console.log("listening on " + ipaddress + ":" + serverport);
	//Listen at that hostname.
	http.listen(serverport, ipaddress);
});
